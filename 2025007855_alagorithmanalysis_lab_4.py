# -*- coding: utf-8 -*-
"""2025007855-AlagorithmAnalysis Lab-4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nrJDOZbe88Uwx92HrPVMhHiiZLF_q1Zt

Implentation of DFS to find shortest path distance between a given node and all other node.
"""

def dfs_shortest_path(graph, start):
        distance = {}
        current_layer = [start]
        next_layer=[]
        distance[start] = 0
        while(current_layer):
          current_node = current_layer.pop(0)
          for neighbor in graph[current_node]:
            if neighbor not in distance:
              distance[neighbor] = distance[current_node] + 1
              next_layer.append(neighbor)

          if neighbor not in distance:
            distance[neighbor] = distance[current_node] + 1
            next_layer.append(neighbor)
          current_layer = next_layer
        return distance

graph= {
    'A': ['B', 'D'],
    'B': ['A', 'C',],
    'C': [ 'B', 'G'],
    'D': ['A','E'],
    'E': ['D','F'],
    'F': ['E','G'],
    'G': ['H','I','C','F'],
    'H': ['G','I'],
    'I': ['H','G'],
      }
dist_path = dfs_shortest_path(graph, 'A')
print(dist_path)

"""#Implementating shortest distance from given start node to end node using BFS"""

def shortest_path(graph, start, end):
    queue =([(start, 0)])
    visited = set()
    visited.add(start)

    while queue:
        node, distance = queue.pop()

        if node == end:
            return distance

        if node in graph:
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append((neighbor, distance + 1))
                    visited.add(neighbor)

    return -1

graph = {
    'A': ['B', 'C'],
    'B': ['A', 'C', 'D'],
    'C': ['E', 'F', 'B', 'A'],
    'D': ['B'],
    'E': ['C'],
    'F': ['C']
}

start = 'A'
end = 'F'

path_length = shortest_path(graph, start, end)
print(f"The shortest path length from {start} to {end} is: {path_length}")

"""#Implementing dfs using recurcive

"""

def dfs_recursive(graph, node, visited):
    if node not in visited:
        print(node, end=" ")   # Process the node
        visited.add(node)
        for neighbor in graph[node]:
            dfs_recursive(graph, neighbor, visited)

# Example usage
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

visited = set()
dfs_recursive(graph, 'A', visited)

"""# implementing shortest path using dfs for two nodes"""

def dfs_shortest_path(graph, start, end, path=None, visited=None, shortest=None):
    if path is None:
        path = []
    if visited is None:
        visited = set()

    path.append(start)
    visited.add(start)

    # If we reached the end node
    if start == end:
        if shortest is None or len(path) < len(shortest):
            shortest = path.copy()
    else:
        for neighbor in graph[start]:
            if neighbor not in visited:
                shortest = dfs_shortest_path(graph, neighbor, end, path, visited, shortest)

    # Backtrack
    path.pop()
    visited.remove(start)

    return shortest

# Example graph as adjacency list
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': ['G'],
    'E': ['G'],
    'F': ['G'],
    'G': []
}

start_node = 'A'
end_node = 'G'

shortest_path = dfs_shortest_path(graph, start_node, end_node)
print("Shortest path:", shortest_path)